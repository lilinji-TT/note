# 前端面试题之网络协议篇

## 1.简述TCP连接的过程

#### TCP协议通过三次握手建立可靠的点对点连接，具体过程：

1. #### 服务端进入监听状态，然后即可处理连接。

2. #### 第一次握手：建立连接时，客户端发送SYN报文至服务器，进入SYN_SENT的状态，等待服务器确认。在发送的包中会包含一个初始的序列号SEQ。此次握手的含义是客户端希望与服务器建立连接。

3. #### 第二次握手：服务器收到SYN报文，之后回应给客户端一个SYN+ACK包，此时服务器进入SYN_RCVD状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。

4. #### 第三次握手：客户端收到服务器的SYN包后，向服务端再次发送ACK包，并进入ESTAB_LISHED状态。

5. #### 服务器收到客户端的ACK包后，进入相同的ESTAB_LISHED状态，至此，建立连接完成。

## 2.介绍下HTTP 1.0、HTTP 1.1 HTTP 2.0的协议区别？

#### 1.0：特点是每次请求和响应完毕后都会销毁TCP连接，同时规定前一个响应完成以后才能发送下一个请求，这样做有两个问题。

- #### 无法复用连接：每次请求都需要创建新的TCP连接，完成三次握手和四次握手，网络利用率低

- #### 队头阻塞：如果前一个请求被某种原因阻塞了，会导致后续请求无法发出。

#### 1.1：1.0的改进版本。

- #### 长连接：1.1允许在请求时增加请求头connection：keep-live，这样就允许后续的客户端请求在一段时间复用之前的TCP连接

- #### 管道化：基于长连接的基础，管道化可以不等第一个请求响应继续发送，但是响应顺序还是按照请求顺序返回。

- #### 缓存处理：新增响应头cache-control，用于实现客户端缓存

- #### 断点传输：在上传或者下载资源时，如果过大，将其分割为多个部分，分别上传或者下载，遇到网络故障，可以从已经上传或者下载的地方继续请求，不用从头开始，提高效率

#### 2.0：进一步优化了传输效率。

- #### 二进制分帧：将传输的消息分为更小的二进制帧，每帧都有自己的标识号，即使被随意打乱也能在另一端正确的组装。

- #### 多路复用：基于二进制帧，在同一域名下所有访问都是从一个TCP连接中走，并且不再有队头阻塞的问题，也无需遵守响应顺序。

- #### 头部压缩：http 2.0通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部数据量，从而实现了更小的传输量。

- #### 服务器推送：2.0允许服务器直接推送消息给客户端，无需客户端明确的请求。

## 3.为什么HTTP/1.1不能实现多路复用？

#### HTTP/1.1不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就不能实现多路复用。

## 4.简单讲解一下HTTP2的多路复用

#### 在HTTP/2中有两个很重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个TCP连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于那个请求。通过这个技术，可以避免HTTP旧版本的队头阻塞问题，极大的提高了传输性能。

## 5.对TCP连接三次握手和四次挥手的理解

#### 三次握手过程见1问。

#### 建立连接完成后，需要进行四次挥手才能关闭。

1. #### 客户端向服务端发送FIN包，表示客户端主动要关闭连接，然后进入FIN_WAIT_1状态，等待服务端返回ACK包。此后客户端不能再向服务端发送数据，但是可以读取数据。

2. #### 服务端收到FIN包后向客户端发送ACK包，然后进入CLOSE_WAIT状态，此后服务端不能再读取数据，但是可以继续发送数据。

3. #### 客户端收到服务端返回的ACK包后进入FIN_WAIT_2状态，等待服务端发送FIN包。

4. #### 服务端完成数据发送后，将FIN包发送给客户端，然后进入LAST_ACK状态，等待客户端返回ACK包，此后服务端既不能读取数据，也不能发送数据。

5. #### 客户端收到FIN包后向服务端发送ACK包，进入TIME_WAIT状态，接着等待足够长的时间以确保服务端接受到ACK包，最后回到CLOSE状态，释放网络资源。

6. #### 服务端收到客户端返回的ACK包后也回到CLOSE状态，释放网络资源。

## 6.介绍HTTPS的握手过程

1. #### 客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息。

2. #### 服务器响应公钥和服务器证书。

3. #### 客户端验证证书是否合法，之后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器。

4. #### 服务器使用私钥解密被加密的会话密钥并且进行保存，之后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪。

5. #### 客户端使用会话密钥解密消息，知道了服务器已经准备就绪。

6. #### 后续客户端和服务器使用会话密钥加密信息传递消息。

## 7.HTTPS握手过程中，客户端如何验证证书的合法性。

1. #### 校验证书的颁发机构是否受客户端信任。

2. #### 通过CRL和OCSP的方式校验证书是否被吊销。

3. #### 对比系统时间，校验证书是否在有效期内。

4. #### 通过校验对方是否存在证书的私钥，判断证书的网站是否与证书颁发的域名一致。 

## 8.HTTP状态码301和302的应用场景分别是什么？

#### 301表示永久重定向，302表示临时重定向。

#### 如果浏览器收到的是301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。但如果浏览器搜到的是302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。因此，301适合地址永久转移的场景，比如域名变更；302则适合临时转移的场景，比如首页临时跳转到活动页。

## 9.COOKIE和TOKEN都放在header里，为什么不会劫持TOKEN？

#### 由于浏览器会自动发送cookie到服务器，因此攻击者可以利用这一点进行csrf攻击。

#### 而通常token不会放在cookie中的，需要浏览器端使用js保存到local storage中，在请求时也需要手动的加入到请求头中，因此不容易引发csrf攻击。

## 10.介绍一下如何实现token加密

#### 以最常见的token格式jwt为例，token分为三段，分别是header、payload、signature。其中、header标识算法和令牌类型；payload标识主体信息，包含令牌过期时间、发布时间、发行者、主题内容等；signature是使用特定的算法对前面两部分进行加密，得到的加密结果。

#### token有防篡改的特点、如果攻击者改动了前面两个部分，就会导致和第三部分对应不上，使得token失效。而攻击者不知道加密密钥，因此又无法修改第三部分的值。所以在不泄露密钥的前提下，一个通过验证的token是值得被信任的。

## 11.单点登录

#### SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。

#### **具体流程是**：

- #### 用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数

- #### sso 认证中心发现用户未登录，将用户引导至登录页面

- #### 用户输入用户名密码提交登录申请

- #### sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌

- #### sso 认证中心带着令牌跳转会最初的请求地址（系统 1）

- #### 系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效

- #### sso 认证中心校验令牌，返回有效，注册系统 1

- #### 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源

- #### 用户访问系统 2 的受保护资源

- #### 系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数

- #### sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌

- #### 系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效

- #### sso 认证中心校验令牌，返回有效，注册系统 2

- #### 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源

## 12.HTTP/1.1是如何复用TCP连接的？

#### 	客户端请求服务器时，通过请求行告诉服务器使用的协议是http1.1，同时在请求头中携带connection：keep-live（为保持兼容），告诉服务器这是一个长连接，后续请求可以重复使用这一次的TCP连接。

#### 	这样做的好处就是减少了三次握手和四次挥手的次数，一定程度上提升了网络利用率。但由于HTTP1.1不支持多路复用，响应顺序必须按照请求顺序抵达客户端，不能真正实现并行传输，因此在http2.0出现之前，实际项目中往往把静态资源，比如图片，分发到不用域名下的资源服务器，以便实现真正的并行传输。

## 13.文件上传如何做到断点续传？

#### 客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时携带上器序号。服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的hash和序号。若上传中止，将来再次上传时，可以向服务器要已上传的分片序号，客户端仅需上传剩余分片即可。当全部分片上传完成以后，服务器按照分片顺序组装成完整的文件，并删除分片文件。

## 14.介绍SSL和TLS

#### 它们都是用于保证传输安全的协议，介于传输层和应用层之间，TLS时SSL的升级版。 

#### 流程：

1. ##### 客户端向服务器索要公钥，并使用数字证书验证公钥。

2. ##### 客户端使用公钥加密会话密钥，服务端用私钥解密会话密钥，于是得到一个双方都认可的会话密钥。

3. ##### 传输的数据使用会话密钥加密，然后再传输，接收消息方使用会话密钥解密得到原始数据。

## 15.说说网络的五层模型

