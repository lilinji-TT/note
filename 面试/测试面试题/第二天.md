## css:有哪些方式可以隐藏页面元素

### display：none

### visibility: hidden

## js: 说一下event loop

### JS是一个单线程的语言

### 	首先代码分为同步代码和异步代码，而异步代码又分为宏任务和微任务，当执行代码时事件循环机制就会介入，浏览器和node环境中这个机制稍有不同。

### 微任务比如:

- ##### Promise.then/catch/finally

- ##### MutationObserver (?)

- ##### process.nextTick（Node.js环境）

### 宏任务比如定时器:

- ##### script（整体代码）

- ##### setTimeout

- ##### setInterval

- ##### setImmediate（Node.js环境）

- ##### requestAnimationFrame（浏览器环境）

- ##### I/O操作

### 浏览器的事件循环：

#### 	在event loop机制中，首先执行完主任务队列中的代码后，会去执行异步队列中的宏任务队列和微任务队列，首先是微任务队列，这个队列中的微任务由第一次执行代码时产生的微任务构成，秉着先进先出的原则执行，当我们的微任务队列中任务被清空后，再去执行宏任务队列中的任务，如果在这过程中产生了新的微任务或者宏任务，会相继压入对应的任务队列的末尾，重复之前的行为，直到两个队列被清空。

### node的事件循环：

#### 	Node中有多个阶段，每个阶段处理特定的任务类型。

## 浏览器：浏览器缓存机制

### 浏览器中的缓存分为强缓存和协商缓存

- #### 强缓存：发起请求的时候，在请求头中添加Cache-Control和Expires字段，就会直接取缓存中的资源

- #### 协商缓存：浏览器会向服务器发送请求，并根据服务器返回的响应头中的ETag和Last-Modified字段，判断本地缓存是否仍然有效。如果仍然有效，则直接从本地缓存中读取资源，否则返回最新的资源。



## vue: vue3 对 vue2 有什么优势

1. #### 响应式：vue3使用ES6的proxy，对比vue2的Object.defineProperty更为强大

2. #### diff算法的优化：在vue2中时进行一个全量的对比，vue3中增加了一个静态标记：新旧虚拟节点进行对比时，只对比携带了标记的节点。减少了对比量，增加了速度。

3. #### vu2中元素不管是不是参与了更新都会被重新创建；vue3中对于不参与更新的元素，仅仅创建一次，之后每次渲染仅是复用

4. #### 事件侦听器缓存：默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化，但是在Vue中，绑定的方法会被缓存起来，下次更新直接复用即可

5. #### 对TS的支持更好

6. #### vue3支持tree-shaking，避免对不必要的文件进行打包，从而使得打包后的文件体积更小

7. #### 编译模板的优化，update性能提高1.3-2倍，SSR速度提高了2-3倍

8. #### composition Api

## react : setState和batchUpdate机制

### `setState`:调用 `setState` 的时候，React 会将传入的更新对象合并到当前状态中，并触发组件的重新渲染。在某个版本以前setState是同步更新的，现在都是异步更新，即当调用 `setState` 时，React 并不会立刻更新组件的状态和视图，而是将状态更新放到一个队列中，等待下一次渲染的时候批量更新(将状态更新放到一个队列，等待下一次渲染，也就是多次调用，进行一次更新渲染)。

### `batchUpdate`(批量更新)：对连续的多次 `setState` 调用的状态更新进行合并，只触发一次重新渲染。
