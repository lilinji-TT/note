## 1.常见的DOM元素居中

## 2.vue2和vue3的响应式区别

1. **Proxy 替代 Object.defineProperty：** 在 Vue 2 中，使用 Object.defineProperty 来实现响应式数据。而在 Vue 3 中，使用 JavaScript 的 Proxy 对象来实现响应式。Proxy 提供了更强大和灵活的拦截器功能，可以捕获更多的操作并对其进行响应。
2. **树级响应式追踪：** Vue 3 通过基于 Proxy 的追踪机制实现了树级响应式。这意味着在 Vue 3 中，响应式数据不仅限于顶层属性，还可以跟踪嵌套属性的变化。
3. **更好的性能：** 由于使用 Proxy 对象和树级响应式追踪，Vue 3 在性能方面有所提升。Vue 3 的响应式系统比 Vue 2 更高效，并且对大型组件树的响应速度更快。

## 3.vue中的指令

## 4.v-if和v-show的区别

`v-if` 和 `v-show` 是 Vue.js 中用于条件渲染的指令，它们之间有一些区别。

`v-if` 的特点和使用情况：

- `v-if` 是一种惰性渲染，当条件为真时，才会渲染对应的元素到 DOM 中；当条件为假时，元素将被从 DOM 中移除。
- `v-if` 在条件切换时，会销毁和重建元素及其子组件。这意味着，当条件从假切换到真时，会触发组件的销毁和重新创建过程，可能会导致性能开销较大。
- `v-if` 适用于在运行时条件很少改变的情况，或者当条件为假时不希望在 DOM 中保留元素的情况。

`v-show` 的特点和使用情况：

- `v-show` 通过 CSS 的 `display` 属性来控制元素的显示和隐藏，而不是添加或移除元素。
- `v-show` 在条件为真时，通过修改元素的 `display` 样式属性将其显示出来；在条件为假时，通过修改样式属性将其隐藏，但仍保留在 DOM 中。
- `v-show` 不会销毁和重建元素及其子组件，因此切换条件时的性能开销较小。
- `v-show` 适用于需要频繁切换显示和隐藏的情况，或者当条件为假时仍希望在 DOM 中保留元素的情况。

根据上述特点，可以总结出以下几点区别：

- 如果需要频繁切换显示和隐藏，或者当条件为假时仍希望在 DOM 中保留元素，可以使用 `v-show`。
- 如果条件不经常改变，或者需要在条件为假时从 DOM 中移除元素以节省资源，可以使用 `v-if`。
- 当组件初始化时，如果条件为假，建议使用 `v-show`，因为它不会在初始渲染时触发组件的销毁和重新创建过程，而 `v-if` 会。
- 当条件经常变化且涉及大量子组件时，可能需要权衡 `v-if` 和 `v-show` 之间的性能开销，选择最适合的指令。

## 5.js、ts的特点区别

##### JavaScript 的特点包括：

1. **动态类型：** JavaScript 是一种动态类型语言，变量的类型在运行时确定，可以根据需要动态改变变量的类型。
2. **解释执行：** JavaScript 是一种解释执行的语言，不需要显式的编译步骤，代码可以直接在浏览器或其他 JS 解释器中执行。
3. **灵活性和宽松性：** JavaScript 具有灵活的语法和宽松的约束，允许开发者进行灵活的编程，但也容易出现隐式类型转换和错误。
4. **浏览器环境：** JavaScript 最初是为在浏览器中添加交互性而创建的，因此在浏览器环境中广泛使用，可以操作 DOM、处理事件等。
5. **生态系统：** JavaScript 拥有庞大的生态系统，有丰富的开源库和框架，支持前端开发、后端开发以及移动端开发等多个领域。

##### TypeScript 是 JavaScript 的一个超集，具有以下特点：

1. **静态类型检查：** TypeScript 引入了静态类型检查，可以在开发过程中捕获常见的错误，并提供更好的代码可读性和可维护性。开发者可以使用类型注解来明确变量的类型，并在编译时进行类型检查。
2. **类型推导：** TypeScript 可以根据上下文自动推导变量的类型，减少了显式的类型注解的需求，提供了更简洁的语法。
3. **更好的面向对象编程支持：** TypeScript 提供了类、接口、泛型等面向对象编程的特性，可以进行模块化和面向对象的代码设计。
4. **编译时类型检查：** TypeScript 在编译时对代码进行类型检查，并将 TypeScript 代码编译为纯粹的 JavaScript 代码，可以在各种环境中运行。
5. **增强的编辑器支持：** TypeScript 提供了丰富的编辑器支持，例如代码补全、类型提示、重构等功能，可以提高开发效率。

## 6.react的dom diff策略

在 React 中，虚拟 DOM 的 diff 策略用于比较两个虚拟 DOM 树之间的差异，并尽可能高效地更新实际 DOM。React 使用了一种称为 "Reconciliation" 的算法来执行这个 diff 过程。

React 的虚拟 DOM diff 策略主要基于以下三个原则：

1. **同层级比较：** React 会按照层级结构逐层比较虚拟 DOM 树的节点，而不会跨越层级进行比较。这样可以最大限度地减少比较的节点数，提高性能。
2. **差异最小化：** React 会尽量找到相同类型的组件或元素进行比较，而不会对完全不同的类型进行比较。只有在同一位置上的节点类型发生变化时，才会销毁旧节点并创建新节点。
3. **使用唯一标识：** 在进行节点比较时，React 使用每个节点的唯一标识（key）来跟踪它们的变化。这样可以更精确地确定节点的添加、移动和删除，而不是简单地按顺序比较。

基于这些原则，React 的 diff 策略会进行以下操作：

1. **创建新节点：** 如果在新的虚拟 DOM 树中找不到对应的旧节点，React 会创建新的实际 DOM 节点并将其添加到页面中。
2. **更新属性：** 如果某个节点在新的虚拟 DOM 树中仍然存在，React 会比较新旧节点的属性，并更新实际 DOM 中的属性值，以确保与虚拟 DOM 保持一致。
3. **递归比较子节点：** 如果某个节点在新旧虚拟 DOM 树中都存在，并且类型相同，React 会递归比较它们的子节点，并对子节点进行相应的更新、添加或删除操作。
4. **移动节点：** 如果节点在新旧虚拟 DOM 树中的位置发生了变化，但是类型相同，React 会将实际 DOM 节点移动到正确的位置，而不是销毁并重新创建。
5. **销毁旧节点：** 如果某个节点在新的虚拟 DOM 树中不存在，React 会将对应的实际 DOM 节点从页面中移除，以进行资源释放。

## 7.虚拟dom的作用，特点

作用是在 JavaScript 内存中创建一个轻量级的、与真实 DOM 结构相似的虚拟树，用于代表页面的结构和状态。然后，通过对比虚拟 DOM 和实际 DOM 的差异，只对需要更新的部分进行最小化的操作，以提高渲染效率。

虚拟 DOM 的特点包括：

1. **轻量高效：** 虚拟 DOM 是在 JavaScript 内存中操作的轻量级对象，相比直接操作真实 DOM，它具有更高的性能和效率。
2. **跨平台：** 虚拟 DOM 不依赖于特定的浏览器平台，可以在不同的浏览器和环境中使用。这使得开发人员可以更加专注于业务逻辑而不必考虑平台差异。
3. **批量更新：** 虚拟 DOM 可以进行批量更新，即将多个 DOM 操作合并为一次更新操作，减少了实际 DOM 操作的次数，提高了性能。
4. **快速比对：** 虚拟 DOM 使用 diff 算法对比前后两个虚拟 DOM 树的差异，只更新发生变化的部分，而不需要重新渲染整个页面。
5. **与真实 DOM 同步：** 虚拟 DOM 会将最终的变更同步到实际 DOM 中，确保页面展现的结果与虚拟 DOM 的状态一致。

## 8.是否使用express写过中间件

## 9.项目中的遇到的难点

## 10.ts类型操作符

1. **Union (`|`)：** Union 操作符用于将多个类型合并为一个联合类型。例如，`string | number` 表示一个类型可以是字符串或数字。
2. **Intersection (`&`)：** Intersection 操作符用于将多个类型交叉合并为一个交叉类型。例如，`A & B` 表示一个类型同时具备 A 和 B 的属性。
3. **Typeof (`typeof`)：** Typeof 操作符用于获取一个值的类型。例如，`typeof x` 返回变量 `x` 的类型。
4. **Keyof (`keyof`)：** Keyof 操作符用于获取一个类型的所有键（属性名）。例如，`keyof T` 返回类型 `T` 的所有键。
5. **Mapped types：** Mapped types 允许在类型层面上遍历和转换属性。例如，`Partial<T>` 将类型 `T` 的所有属性都转换为可选属性。
6. **Conditional types（条件类型）：** Conditional types 是一种在编译时根据条件选择不同类型的方式。它使用 `extends` 关键字和条件表达式来进行类型推断。

## 11.react中常用的hook，useEffect的使用场景。

useEffect常见的使用场景：

1. **数据获取和订阅：** 可以在 `useEffect` 中发送网络请求获取数据，并在获取到数据后更新组件的状态。也可以在 `useEffect` 中订阅事件或监听器，处理数据的变化。
2. **副作用操作：** 可以在 `useEffect` 中执行需要在组件渲染完成后才能进行的操作，例如修改 DOM、操作浏览器历史记录、处理定时器或动画等。
3. **清除副作用：** 可以在 `useEffect` 返回的函数中执行清除副作用的操作，例如取消订阅事件、清除定时器、取消请求等。
4. **依赖项控制：** 可以通过传递依赖项数组来控制 `useEffect` 的触发时机。只有依赖项发生变化时，`useEffect` 中的副作用函数才会重新执行。

请注意，`useEffect` 中的副作用函数默认会在每次组件渲染完成后执行。如果只希望在组件挂载和卸载时执行副作用操作，可以将空数组 `[]` 作为依赖项传递。

## 12.react父子组件的通信方式

1. **Props（属性）：** 父组件通过将数据或回调函数作为 props 属性传递给子组件来实现通信。子组件通过读取 props 属性来获取父组件传递的数据，并且可以调用回调函数来向父组件传递信息。
2. **Context（上下文）：** Context 提供了一种在组件树中共享数据的方式，父组件可以通过创建一个 Context 并将数据存储在其中，然后将 Context 作为 prop 传递给子组件。子组件可以通过访问 Context 来获取共享的数据。
3. **Redux 或其他状态管理库：** 如果应用程序的状态管理较为复杂，可以使用 Redux 或其他类似的状态管理库。这些库提供了一种集中式管理应用程序状态的方式，使得父组件和子组件可以通过订阅和分发 actions 的方式进行通信。
4. **Callback 函数：** 父组件可以将一个函数作为 props 传递给子组件，子组件可以通过调用这个函数来向父组件传递数据或触发特定的操作。